import{_ as s,c as a,o as e,ag as l}from"./chunks/framework.DPDPlp3K.js";const c=JSON.parse('{"title":"Reflow와 Repaint","description":"","frontmatter":{},"headers":[],"relativePath":"modern/reflow.md","filePath":"modern/reflow.md"}'),t={name:"modern/reflow.md"};function n(h,i,o,p,d,r){return e(),a("div",null,i[0]||(i[0]=[l(`<h1 id="reflow와-repaint" tabindex="-1">Reflow와 Repaint <a class="header-anchor" href="#reflow와-repaint" aria-label="Permalink to &quot;Reflow와 Repaint&quot;">​</a></h1><h3 id="repaint" tabindex="-1">Repaint <a class="header-anchor" href="#repaint" aria-label="Permalink to &quot;Repaint&quot;">​</a></h3><p>재결합된 렌더 트리를 기반으로 다시 화면에 페인트하는 것을 말해요.</p><h3 id="reflow" tabindex="-1">Reflow <a class="header-anchor" href="#reflow" aria-label="Permalink to &quot;Reflow&quot;">​</a></h3><p>레이아웃 계산을 다시 하는 것을 말해요, Reflow가 발생하면 Repaint는 필연적으로 발생해요. Reflow가는 HTML 요소들의 위치와 크기를 다시 계산해야 하기 때문에, 리페인트에 비해서 시간이 오래걸려요.</p><p>변경하려는 특정 요소의 위치와 크기뿐 아니라, 연관된 다른 요소들의 위치와 크기까지 재계산해야 하기 때문이죠. 따라서 <strong>리플로우가 자주 발생하도록 하는 코드는 지양해야해요.</strong></p><h2 id="reflow가-발생하는-이유" tabindex="-1"><strong>Reflow가 발생하는 이유</strong> <a class="header-anchor" href="#reflow가-발생하는-이유" aria-label="Permalink to &quot;**Reflow가 발생하는 이유**&quot;">​</a></h2><p>Reflow는 다음과 같은 경우에 발생합니다.</p><ol><li><strong>DOM 변경</strong><ul><li>새로운 요소가 추가되거나 삭제될 때</li><li>노드의 위치, 크기, 패딩, 마진 등이 변경될 때</li></ul></li><li><strong>스타일 변경</strong><ul><li>CSS 속성이 변경될 때 - 특히 레이아웃에 영향을 미치는 속성! (<code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>, <code>border</code>)이 변경될 때</li></ul></li><li><strong>윈도우 크기 변경</strong><ul><li>사용자가 브라우저 창 크기를 조정했을 때 전체 레이아웃 다시 계산</li></ul></li><li><strong>동적 콘텐츠 변경</strong><ul><li>JS로 텍스트를 추가하거나 DOM 노드를 조작할 때</li></ul></li><li><strong>CSS의 특정 속성 사용</strong><ul><li><code>display</code>, <code>position</code>, <code>float</code>, <code>clear</code>, <code>vertical-align</code> 등의 속성이 바뀔 때</li></ul></li><li><strong>특정 메소드 호출</strong><ul><li><code>offsetWidth</code>, <code>offsetHeight</code>, <code>clientWidth</code>, <code>clientHeight</code> 등의 메소드를 호출할 때 -&gt; 브라우저는 최신 레이아웃 정보를 제공하기 위해 Reflow를 강제할 수 있어요.</li></ul></li></ol><h2 id="reflow-방지하는-방법" tabindex="-1"><strong>Reflow 방지하는 방법</strong> <a class="header-anchor" href="#reflow-방지하는-방법" aria-label="Permalink to &quot;**Reflow 방지하는 방법**&quot;">​</a></h2><h4 id="_1-dom-조작-최소화" tabindex="-1">1. DOM 조작 최소화 <a class="header-anchor" href="#_1-dom-조작-최소화" aria-label="Permalink to &quot;1. DOM 조작 최소화&quot;">​</a></h4><ul><li>DOM 요소를 조작하기 전에 변경 사항을 모아 한 번에 적용해보세요. 예를들어 DOM 요소를 반복적으로 추가하거나 수정하는 대신 <code>DocumentFragment</code>를 사용해 한 번에 추가하세요.</li></ul><h4 id="_2-details-css-최적화" tabindex="-1">2. details CSS 최적화 <a class="header-anchor" href="#_2-details-css-최적화" aria-label="Permalink to &quot;2. details CSS 최적화&quot;">​</a></h4><ul><li>CSS에서 복잡한 선택자 특히 후손 선택자 (ex. div &gt; div &gt; div)를 피하고 간결한 선택자를 사용해봐요.</li><li>애니메이션이나 UI전환은 <code>transform</code> <code>opacity</code>와 같은 레이아웃을 변경하지 않는 속성을 활용해봐요.</li></ul><h4 id="_3-배치-스타일-변경" tabindex="-1">3. 배치 스타일 변경 <a class="header-anchor" href="#_3-배치-스타일-변경" aria-label="Permalink to &quot;3. 배치 스타일 변경&quot;">​</a></h4><ul><li><p>JS로 스타일을 변경할 때는 한 번에 여러 스타일을 설정해봐요.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 비효율적</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;100px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 효율적</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.cssText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;width: 100px; height: 100px;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ul><h4 id="_4-레이아웃-읽기와-쓰기-분리" tabindex="-1">4. 레이아웃 읽기와 쓰기 분리 <a class="header-anchor" href="#_4-레이아웃-읽기와-쓰기-분리" aria-label="Permalink to &quot;4. 레이아웃 읽기와 쓰기 분리&quot;">​</a></h4><ul><li><p>레이아웃 읽기(<code>offsetWidth</code>, <code>clientHeight</code>)와 쓰기(스타일 변경)를 번갈아 하지 마세요.</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 비효율적</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetHeight;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;px&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 효율적</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetHeight;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}px\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li></ul><h4 id="_5-cssom-및-레이아웃-변경-최소화" tabindex="-1">5. CSSOM 및 레이아웃 변경 최소화 <a class="header-anchor" href="#_5-cssom-및-레이아웃-변경-최소화" aria-label="Permalink to &quot;5. CSSOM 및 레이아웃 변경 최소화&quot;">​</a></h4><ul><li>애니메이션이나 인터랙션에서는 <code>will-change</code> 속성을 사용해 브라우저가 최적화를 할 수 있도록 해요.</li><li>복잡한 레이아웃 작업이 필요한 경우, 해당 요소에 <code>position: absolute</code> 또는 <code>position: fixed</code>를 설정해 독립적인 레이어로 처리해봐요.</li></ul><h4 id="_6-서브트리-최적화" tabindex="-1">6. 서브트리 최적화 <a class="header-anchor" href="#_6-서브트리-최적화" aria-label="Permalink to &quot;6. 서브트리 최적화&quot;">​</a></h4><ul><li>DOM의 최상위 레벨 요소를 변경하는 대신 특정 서브트리(subtree)만 변경해요.</li></ul><hr><hr><div class="info custom-block"><p class="custom-block-title">간단 요약</p><p>브라우저의 Reflow는 웹 페이지의 레이아웃이 다시 계산되는 과정을 말해요. DOM의 일부가 변경되면서 브라우저가 해당 변경 사항에 따라 레이아웃을 재계산해야 할 때 발생합니다. Reflow는 CPU와 메모리를 소모하며, 과도하게 발생하면 성능 저하를 유발할 수 있어요!</p></div>`,25)]))}const g=s(t,[["render",n]]);export{c as __pageData,g as default};
